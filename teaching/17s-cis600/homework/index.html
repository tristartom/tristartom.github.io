<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h2 id="homework-1">Homework 1</h2>
<ol style="list-style-type: decimal">
<li>[Exercise 2.7] When using the one-time pad with the key k = <span class="math">0<sup><em>l</em></sup></span>, we have <span class="math"><em>E</em><em>n</em><em>c</em><sub><em>k</em></sub>(<em>m</em>) = <em>k</em> ⊕ <em>m</em> = <em>m</em></span> and the message is sent in the clear! It has therefore been suggested to modify the one-time pad by only encrypting with <span class="math"><em>k</em>! = 0<sup><em>l</em></sup></span> (i.e., to have Gen choose k uniformly from the set of nonzero keys of length l). Is this modified scheme still perfectly secret? Explain. Note <span class="math"> ⊕ </span> is XOR.</li>
<li>Prove that we may assume that the key-generation algorithm Gen always chooses a key uniformly from the key space K.</li>
<li>[Bonus:30/100] [Exercise 3.4]: Prove the equivalence of Definition 3.8 and Definition 3.9.</li>
</ol>
<h2 id="homework-2">Homework 2</h2>
<ol style="list-style-type: decimal">
<li><strong>CPA-secure variable-length PrivK encryption (stream cipher)</strong> Write programs (with language of your choice) to implement the following:
<ol style="list-style-type: decimal">
<li>one-time pad</li>
<li>the RC4 stream cipher (read chapter 6.1.4 in textbook)</li>
<li>construction 3.17</li>
<li>domain extension for a variable-length encryption based on 3); hint: use stream-cipher mode of operation (read 3.6.1). Note no block cipher is allowed in the implementation.</li>
</ol></li>
<li>[Exercise 3.20]: Consider a stateful variant of CBC-mode encryption where the sender simply increments the IV by 1 each time a message is encrypted (rather than choosing IV at random each time). Show that the resulting scheme is not CPA-secure.</li>
<li>[Bonus: 30/100] Write down the proof of security for Theorem 3.18 IN YOUR OWN LANGUAGE. Don't copy and paste from the textbook.</li>
</ol>
<h2 id="homework-3">Homework 3</h2>
<ol style="list-style-type: decimal">
<li><strong>CPA-secure variable-length PrivK encryption (block cipher)</strong> Write programs (with language of your choice) to implement a CPA-secure encryption scheme based on block cipher. In your implementation, you can assume a insecure block cipher (e.g. a fixed permutation or even an identity function). Specifically, implement construction for the following schemes:
<ol style="list-style-type: decimal">
<li>Fixed-length encryption (with scheme of your choice),</li>
<li>Variable-length encryption; use CBC mode for domain extension.</li>
</ol></li>
<li><strong>OpenSSL</strong> Read online [<a href="http://cs.uccs.edu/~cs691/crypto/openssl/example.htm">tutorial</a>], finish the following operations. Upload the screenshots as your solution.
<ol style="list-style-type: decimal">
<li>create a self signed CA certificate</li>
<li>generate private-public key pair bind to an user, say <code>CIS600</code></li>
<li>request a certificate of user <code>CIS600</code> to CA for signing; (hint: use <code>CIS600</code>'s public key as his identity)</li>
<li>use the public-private key pair to encrypt and decrypt messages</li>
<li>use the public-private key pair to sign and verify messages</li>
</ol></li>
<li>[Exercise 10.4] Consider the following key-exchange protocol: (a) Alice chooses uniform <span class="math"><em>k</em>, <em>r</em></span> in <span class="math">{0, 1}<sup><em>n</em></sup></span>, and sends <span class="math"><em>s</em> := <em>k</em> ⊕ <em>r</em></span> to Bob. (b) Bob chooses uniform <span class="math"><em>t</em></span> in <span class="math">{0, 1}<sup><em>n</em></sup></span>, and sends <span class="math"><em>u</em> := <em>s</em> ⊕ <em>t</em></span> to Alice. (c) Alice computes <span class="math"><em>w</em> := <em>u</em> ⊕ <em>r</em></span> and sends <span class="math"><em>w</em></span> to Bob. (d) Alice outputs <span class="math"><em>k</em></span> and Bob outputs <span class="math"><em>w</em> ⊕ <em>t</em></span>. Show that Alice and Bob output the same key. Analyze the security of the scheme (i.e., either prove its security or show a concrete attack). Note <span class="math"> ⊕ </span> is XOR.</li>
</ol>
<!--

Amin's sol:

    1. create a self signed CA certificate

mkdir private
openssl req -new -x509 -keyout private/cakey.pem -out cacert.pem -days 365 -config /etc/ssl/openssl.cnf

#cakey.pem private key
#cacert.pem certificate

    2. generate private-public key pair bind to an user, say `CIS600`
    3. request a certificate of user `CIS600` to CA for signing; (hint: use `CIS600`'s public key as his identity)

cp private/cakey.pem private/cakey.pem.enc
openssl rsa -in private/cakey.pem.enc -out private/cakey.pem

#

openssl req -nodes -new -x509 -keyout cs691privatekey.pem -out cs691req.pem -days 365 -config /etc/ssl/openssl.cnf
openssl x509 -x509toreq -in cs691req.pem -signkey cs691privatekey.pem -out cs691certrequest.pem

#/*** here we need to make a couple of files, otherwise the next openssl command will produce errors ***/
#mkdir newcerts; touch index.txt; echo 01>serial; Edit /etc/ssl/openssl.cnf and set two appearances of dir= CADemo to dir= .
openssl ca -config /etc/ssl/openssl.cnf -policy policy_anything -out cs691signedcert.pem -infiles cs691certrequest.pem
cp cs691privatekey.pem private/cs691privatekey.pem
openssl rsa -in private/cs691privatekey.pem -passin pass:cs03se -pubout -out cs691publickey.pem

    4. use the public-private key pair to encrypt and decrypt messages
    5. use the public-private key pair to sign and verify messages 

echo "sometext">plain.txt
openssl rsautl -encrypt -pubin -inkey cs691publickey.pem -in plain.txt -out cipher.txt
openssl rsautl -decrypt -inkey private/cs691privatekey.pem -in cipher.txt -out plainRcv.txt
openssl sha1 -out digest.txt plain.txt
openssl sha1 -sign private/cs691privatekey.pem -out rsasign.bin plain.txt
openssl sha1 -verify cs691publickey.pem -signature rsasign.bin plain.txt
-->
<h2 id="homework-4">Homework 4</h2>
<ol style="list-style-type: decimal">
<li><strong>Merkle tree collision-resistance</strong> [Exercise 5.12] Prove theorem 5.11, that is, the hash-resistance of Merkle tree depends on the hash-resistance of the hash function used in Merkle tree.</li>
<li><strong>Merkle tree for variable-length hash</strong> [Exercise 5.13] Show how to find a collision in the Merkle tree construction if <span class="math"><em>t</em></span> is not fixed. Specifically, show how to find two sets of inputs <span class="math"><em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>t</em></sub></span> and <span class="math"><em>x</em><sub>1</sub>′, ..., <em>x</em><sub>2<em>t</em></sub>′</span>, such that <span class="math"><em>M</em><em>T</em><sub><em>t</em></sub>(<em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>t</em></sub>) = <em>M</em><em>T</em><sub>2<em>t</em></sub>(<em>x</em><sub>1</sub>′, ..., <em>x</em><sub>2<em>t</em></sub>′)</span>.
<ul>
<li>Can you design an approach to fix the problem and have variable-length collision resistant Merkle tree?</li>
</ul></li>
<li>[Bonus: 20/100] Consider using Merkle tree to digest a list of <em>distinct</em> messages. Can Merkle digest support the merge operation of two such lists? Specifically, given lists <span class="math"><em>l</em><sub>1</sub></span> and <span class="math"><em>l</em><sub>2</sub></span>, will it be possible to calculate the Merkle digest <span class="math"><em>M</em><em>T</em>(<em>l</em><sub>1</sub> ∪ <em>l</em><sub>2</sub>)</span> directly from Merkle digests <span class="math"><em>M</em><em>T</em>(<em>l</em><sub>1</sub>)</span> and <span class="math"><em>M</em><em>T</em>(<em>l</em><sub>2</sub>)</span> without knowing <span class="math"><em>l</em><sub>1</sub></span> and <span class="math"><em>l</em><sub>2</sub></span> (<span class="math"> ∪ </span> is merging two lists)? If yes, give an example. If no, prove your claim.</li>
<li><strong>Authenticated Data Structures</strong> [Exercise 1 from book <code>BtC</code> (Bitcoin and Cryptocurrency Technologies); Page 49].
<ul>
<li>hint: In Merkle tree, sublinear proof of non-membership is very similar to that of proving membership.</li>
</ul></li>
</ol>
<h2 id="homework-5">Homework 5</h2>
<ol style="list-style-type: decimal">
<li><strong>Model of Mining</strong> [Exercise 6a, 6b from book <code>BtC</code> (Bitcoin and Cryptocurrency Technologies); Page 74].
<ul>
<li>hint: read chapter 2.4</li>
<li>further reading about probability used in Blockchain: [<a href="https://arxiv.org/abs/1701.03977">pdf</a>]</li>
</ul></li>
<li><strong>Blockchain Mining: Ethereum </strong>: Ethereum is currently the second largest public Blockchain network (only after BitCoin).
<ul>
<li>Install Ethereum commandline tools (client <code>eth</code> recommended) by following [<a href="https://www.ethereum.org/cli">tutorial</a>] on your computer.</li>
<li>Then, follow section &quot;How do I mine ether?&quot; in [<a href="https://ethereum.org/ether">tutorial</a>], and run CPU mining for a period of time (e.g. 10 min). Submit the screenshot of your mining process as the result.</li>
<li>[Bonus] Install Ubuntu 12.04 (e.g. as a guest OS in VirtualBox) and repeat the previous steps to do the mining in Ubuntu 12.04. Submit your screenshot.</li>
</ul></li>
</ol>
<!--

3. **Blockchain Mining (2): OrangeGrid **:
    - Connect to OrangeGrid [[tutorial](http://researchcomputing.syr.edu/connecting-to-orangegrid/)], and submit a hello-world job there by following [[tutorial](http://researchcomputing.syr.edu/running-your-job/)]
        - Note: if you have problem accessing OrangeGrid, send the instructor an email with your SU email account.
    - Package your mining script and the dependent Ethereum software (from Problem 2) to create a Condor job. Submit it for execution to OrangeGrid. When you complete the mining job, submit the screenshot as solution.


4. Smart contracts are programs running on the storage of Blockchain. They are written in a special-purpose language, [[tutorial](https://www.ethereum.org/greeter)]. Write a hello-world smart contract on Ethereum. Submit your program source code and the screenshot of compilation and execution.

-->
</body>
</html>
