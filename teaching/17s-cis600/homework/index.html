<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h2 id="homework-1">Homework 1</h2>
<ol style="list-style-type: decimal">
<li>[Exercise 2.7] When using the one-time pad with the key k = <span class="math">0<sup><em>l</em></sup></span>, we have <span class="math"><em>E</em><em>n</em><em>c</em><sub><em>k</em></sub>(<em>m</em>) = <em>k</em> ⊕ <em>m</em> = <em>m</em></span> and the message is sent in the clear! It has therefore been suggested to modify the one-time pad by only encrypting with <span class="math"><em>k</em>! = 0<sup><em>l</em></sup></span> (i.e., to have Gen choose k uniformly from the set of nonzero keys of length l). Is this modified scheme still perfectly secret? Explain. Note <span class="math"> ⊕ </span> is XOR.</li>
<li>Prove that we may assume that the key-generation algorithm Gen always chooses a key uniformly from the key space K.</li>
<li>[Bonus:30/100] [Exercise 3.4]: Prove the equivalence of Definition 3.8 and Definition 3.9.</li>
</ol>
<h2 id="homework-2">Homework 2</h2>
<ol style="list-style-type: decimal">
<li><strong>variable-length PrivK encryption (stream cipher)</strong> Write programs (with language of your choice) to implement the following:
<ol style="list-style-type: decimal">
<li>one-time pad</li>
<li>the RC4 stream cipher (read chapter 6.1.4 in textbook)</li>
<li>construction 3.17</li>
<li>domain extension for a variable-length encryption based on 3); hint: use stream-cipher mode of operation (read 3.6.1). Note no block cipher is allowed in the implementation.</li>
</ol></li>
<li>[Exercise 3.20]: Consider a stateful variant of CBC-mode encryption where the sender simply increments the IV by 1 each time a message is encrypted (rather than choosing IV at random each time). Show that the resulting scheme is not CPA-secure.</li>
<li>[Bonus: 30/100] Write down the proof of security for Theorem 3.18 IN YOUR OWN LANGUAGE. Don't copy and paste from the textbook.</li>
</ol>
<h2 id="homework-3">Homework 3</h2>
<ol style="list-style-type: decimal">
<li><strong>CPA-secure variable-length PrivK encryption (block cipher)</strong> Write programs (with language of your choice) to implement a CPA-secure encryption scheme based on block cipher. In your implementation, you can assume a insecure block cipher (e.g. a fixed permutation or even an identity function). Specifically, implement construction for the following schemes:
<ol style="list-style-type: decimal">
<li>Fixed-length encryption (with scheme of your choice),</li>
<li>Variable-length encryption; use CBC mode for domain extension.</li>
</ol></li>
<li><strong>OpenSSL</strong> Read online [<a href="http://cs.uccs.edu/~cs691/crypto/openssl/example.htm">tutorial</a>], finish the following operations. Upload the screenshots as your solution.
<ol style="list-style-type: decimal">
<li>create a self signed CA certificate</li>
<li>generate private-public key pair bind to an user, say <code>CIS600</code></li>
<li>request a certificate of user <code>CIS600</code> to CA for signing; (hint: use <code>CIS600</code>'s public key as his identity)</li>
<li>use the public-private key pair to encrypt and decrypt messages</li>
<li>use the public-private key pair to sign and verify messages</li>
</ol></li>
<li>[Exercise 10.4] Consider the following key-exchange protocol: (a) Alice chooses uniform <span class="math"><em>k</em>, <em>r</em></span> in <span class="math">{0, 1}<sup><em>n</em></sup></span>, and sends <span class="math"><em>s</em> := <em>k</em> ⊕ <em>r</em></span> to Bob. (b) Bob chooses uniform <span class="math"><em>t</em></span> in <span class="math">{0, 1}<sup><em>n</em></sup></span>, and sends <span class="math"><em>u</em> := <em>s</em> ⊕ <em>t</em></span> to Alice. (c) Alice computes <span class="math"><em>w</em> := <em>u</em> ⊕ <em>r</em></span> and sends <span class="math"><em>w</em></span> to Bob. (d) Alice outputs <span class="math"><em>k</em></span> and Bob outputs <span class="math"><em>w</em> ⊕ <em>t</em></span>. Show that Alice and Bob output the same key. Analyze the security of the scheme (i.e., either prove its security or show a concrete attack). Note <span class="math"> ⊕ </span> is XOR.</li>
</ol>
<!--

Amin's sol:

    1. create a self signed CA certificate

mkdir private
openssl req -new -x509 -keyout private/cakey.pem -out cacert.pem -days 365 -config /etc/ssl/openssl.cnf

#cakey.pem private key
#cacert.pem certificate

    2. generate private-public key pair bind to an user, say `CIS600`
    3. request a certificate of user `CIS600` to CA for signing; (hint: use `CIS600`'s public key as his identity)

cp private/cakey.pem private/cakey.pem.enc
openssl rsa -in private/cakey.pem.enc -out private/cakey.pem

#

openssl req -nodes -new -x509 -keyout cs691privatekey.pem -out cs691req.pem -days 365 -config /etc/ssl/openssl.cnf
openssl x509 -x509toreq -in cs691req.pem -signkey cs691privatekey.pem -out cs691certrequest.pem

#/*** here we need to make a couple of files, otherwise the next openssl command will produce errors ***/
#mkdir newcerts; touch index.txt; echo 01>serial; Edit /etc/ssl/openssl.cnf and set two appearances of dir= CADemo to dir= .
openssl ca -config /etc/ssl/openssl.cnf -policy policy_anything -out cs691signedcert.pem -infiles cs691certrequest.pem
cp cs691privatekey.pem private/cs691privatekey.pem
openssl rsa -in private/cs691privatekey.pem -passin pass:cs03se -pubout -out cs691publickey.pem

    4. use the public-private key pair to encrypt and decrypt messages
    5. use the public-private key pair to sign and verify messages 

echo "sometext">plain.txt
openssl rsautl -encrypt -pubin -inkey cs691publickey.pem -in plain.txt -out cipher.txt
openssl rsautl -decrypt -inkey private/cs691privatekey.pem -in cipher.txt -out plainRcv.txt
openssl sha1 -out digest.txt plain.txt
openssl sha1 -sign private/cs691privatekey.pem -out rsasign.bin plain.txt
openssl sha1 -verify cs691publickey.pem -signature rsasign.bin plain.txt
-->
<h2 id="homework-4">Homework 4</h2>
<ol style="list-style-type: decimal">
<li><strong>Merkle tree collision-resistance</strong> [Exercise 5.12] Prove theorem 5.11, that is, the hash-resistance of Merkle tree depends on the hash-resistance of the hash function used in Merkle tree.</li>
<li><strong>Merkle tree for variable-length hash</strong> [Exercise 5.13] Show how to find a collision in the Merkle tree construction if <span class="math"><em>t</em></span> is not fixed. Specifically, show how to find two sets of inputs <span class="math"><em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>t</em></sub></span> and <span class="math"><em>x</em><sub>1</sub>′, ..., <em>x</em><sub>2<em>t</em></sub>′</span>, such that <span class="math"><em>M</em><em>T</em><sub><em>t</em></sub>(<em>x</em><sub>1</sub>, ..., <em>x</em><sub><em>t</em></sub>) = <em>M</em><em>T</em><sub>2<em>t</em></sub>(<em>x</em><sub>1</sub>′, ..., <em>x</em><sub>2<em>t</em></sub>′)</span>.
<ul>
<li>Can you design an approach to fix the problem and have variable-length collision resistant Merkle tree?</li>
</ul></li>
<li>[Bonus: 20/100] Consider a variable-length Merkle-tree scheme <span class="math"><em>M</em><em>T</em></span> and a message space <span class="math">𝕄</span> where there is an ordering scheme (i.e. total order between two messages). Use <span class="math"><em>M</em><em>T</em><sub>𝕄</sub></span> to digest an ordered list of <em>distinct</em> messages. Can <span class="math"><em>M</em><em>T</em><sub>𝕄</sub></span> support the merge operation of the two lists? Given two lists, the merge result is an ordered list of distinct messages. Formally, consider two lists <span class="math"><em>m</em><sup><em>A</em></sup> = <em>m</em><sub>1</sub><sup><em>A</em></sup><em>m</em><sub>2</sub><sup><em>A</em></sup>...<em>m</em><sub><em>t</em></sub><sup><em>A</em></sup></span> and <span class="math"><em>m</em><sup><em>B</em></sup> = <em>m</em><sub>1</sub><sup><em>B</em></sup><em>m</em><sub>2</sub><sup><em>B</em></sup>...<em>m</em><sub><em>t</em>′</sub><sup><em>B</em></sup></span> where (w.o.l.g.) <span class="math"><em>m</em><sub>1</sub><sup><em>A</em></sup> &lt; <em>m</em><sub>2</sub><sup><em>A</em></sup> &lt; ... &lt; <em>m</em><sub><em>t</em></sub><sup><em>A</em></sup></span> and <span class="math"><em>m</em><sub>1</sub><sup><em>B</em></sup> &lt; <em>m</em><sub>2</sub><sup><em>B</em></sup> &lt; ... &lt; <em>m</em><sub><em>t</em>′</sub><sup><em>B</em></sup></span>. <span class="math"><em>m</em> := <em>m</em><em>e</em><em>r</em><em>g</em><em>e</em>(<em>m</em><sup><em>A</em></sup>, <em>m</em><sup><em>B</em></sup>)</span> where <span class="math"><em>m</em></span> contains all blocks in <span class="math">{<em>m</em><sub>1</sub><sup><em>A</em></sup>, <em>m</em><sub>2</sub><sup><em>A</em></sup>, ..., <em>m</em><sub><em>t</em></sub><sup><em>A</em></sup>, <em>m</em><sub>1</sub><sup><em>B</em></sup>, <em>m</em><sub>2</sub><sup><em>B</em></sup>, ..., <em>m</em><sub><em>t</em>′</sub><sup><em>B</em></sup></span>, is an ordered list, and has all blocks distinct. Denote by <span class="math"><em>d</em><sup><em>A</em></sup></span> the root hash of Merkle tree <span class="math"><em>M</em><em>T</em><sub>𝕄</sub>(<em>m</em><sup><em>A</em></sup>)</span> and <span class="math"><em>d</em><sup><em>B</em></sup></span> that of <span class="math"><em>M</em><em>T</em><sub>𝕄</sub>(<em>m</em><sup><em>B</em></sup>)</span>. Would it be possible to compute <span class="math"><em>d</em></span>, the root hash of <span class="math"><em>M</em><em>T</em><sub>𝕄</sub>(<em>m</em><em>e</em><em>r</em><em>g</em><em>e</em>(<em>m</em><sup><em>A</em></sup>, <em>m</em><sup><em>B</em></sup>))</span> directly from <span class="math"><em>d</em><sup><em>A</em></sup></span> and <span class="math"><em>d</em><sup><em>B</em></sup></span>?
<ul>
<li>Hint: To make it non-trivial, one can ignore the case that two lists are non-overlapping and totally-ordered.</li>
</ul></li>
<li><strong>Authenticated Data Structures</strong> [Exercise 1 from book <code>BtC</code> (Bitcoin and Cryptocurrency Technologies); Page 49].
<ul>
<li>hint: In Merkle tree, sublinear proof of non-membership is very similar to that of proving membership.</li>
</ul></li>
</ol>
<h2 id="homework-5">Homework 5</h2>
<ol style="list-style-type: decimal">
<li><strong>Model of Mining</strong> [Exercise 6a, 6b from book <code>BtC</code> (Bitcoin and Cryptocurrency Technologies); Page 74].
<ul>
<li>hint: read chapter 2.4</li>
<li>further reading about probability used in Blockchain: [<a href="https://arxiv.org/abs/1701.03977">pdf</a>]</li>
</ul></li>
<li>Project 1: <strong>Blockchain Mining</strong>: [<a href="https://blackboard.syr.edu/bbcswebdav/courses/41635.1172/project.pdf">Link in BB</a>]</li>
</ol>
</body>
</html>
