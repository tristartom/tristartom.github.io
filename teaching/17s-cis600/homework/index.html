<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h2 id="homework-1">Homework 1</h2>
<ol style="list-style-type: decimal">
<li>[Exercise 2.7] When using the one-time pad with the key k = <span class="math">0<sup><em>l</em></sup></span>, we have <span class="math"><em>E</em><em>n</em><em>c</em><sub><em>k</em></sub>(<em>m</em>) = <em>k</em> ⊕ <em>m</em> = <em>m</em></span> and the message is sent in the clear! It has therefore been suggested to modify the one-time pad by only encrypting with <span class="math"><em>k</em>! = 0<sup><em>l</em></sup></span> (i.e., to have Gen choose k uniformly from the set of nonzero keys of length l). Is this modified scheme still perfectly secret? Explain. Note <span class="math"> ⊕ </span> is XOR.</li>
<li>Prove that we may assume that the key-generation algorithm Gen always chooses a key uniformly from the key space <span class="math">$\math{K}$</span>.
<ul>
<li>Hint: Given any encryption scheme with the keys generated following <em>any distribution</em>, you may want to find an equivalent form of the encryption scheme with keys generated uniformly.</li>
</ul></li>
<li>[Bonus:30/100] [Exercise 3.4]: Prove the equivalence of Definition 3.8 and Definition 3.9.</li>
</ol>
<!--

Homework 2
---

1. **variable-length PrivK encryption (stream cipher)** Write programs (with language of your choice) to implement the following: 
    1. one-time pad
    2. the RC4 stream cipher (read chapter 6.1.4 in textbook) 
    3. construction 3.17 
    4. domain extension for a variable-length encryption based on 3); hint: use stream-cipher mode of operation (read 3.6.1). Note no block cipher is allowed in the implementation.
2. [Exercise 3.20]: Consider a stateful variant of CBC-mode encryption where the sender simply increments the IV by 1 each time a message is encrypted (rather than choosing IV at random each time). Show that the resulting scheme is not CPA-secure.
3. [Bonus: 30/100] Write down the proof of security for Theorem 3.18 IN YOUR OWN LANGUAGE. Don't copy and paste from the textbook.

Homework 3
---

1. **CPA-secure variable-length PrivK encryption (block cipher)** Write programs (with language of your choice) to implement a CPA-secure encryption scheme based on block cipher. In your implementation, you can assume a insecure block cipher (e.g. a fixed permutation or even an identity function). Specifically, implement construction for the following schemes:
    1. Fixed-length encryption (with scheme of your choice),
    2. Variable-length encryption; use CBC mode for domain extension.
2. **OpenSSL** Read online [[tutorial](http://cs.uccs.edu/~cs691/crypto/openssl/example.htm)], finish the following operations. Upload the screenshots as your solution.
    1. create a self signed CA certificate
    2. generate private-public key pair bind to an user, say `CIS600`
    3. request a certificate of user `CIS600` to CA for signing; (hint: use `CIS600`'s public key as his identity)
    4. use the public-private key pair to encrypt and decrypt messages
    5. use the public-private key pair to sign and verify messages 
3. [Exercise 10.4] Consider the following key-exchange protocol: (a) Alice chooses uniform $k, r$ in $\{0,1\}^n$, and sends $s := k\oplus{}r$ to Bob. (b) Bob chooses uniform $t$ in $\{0,1\}^n$, and sends $u := s\oplus{}t$ to Alice. (c) Alice computes $w := u\oplus{}r$ and sends $w$ to Bob. (d) Alice outputs $k$ and Bob outputs $w\oplus{}t$. Show that Alice and Bob output the same key. Analyze the security of the scheme (i.e., either prove its security or show a concrete attack). Note $\oplus$ is XOR.
-->
<!--

Amin's sol:

    1. create a self signed CA certificate

mkdir private
openssl req -new -x509 -keyout private/cakey.pem -out cacert.pem -days 365 -config /etc/ssl/openssl.cnf

#cakey.pem private key
#cacert.pem certificate

    2. generate private-public key pair bind to an user, say `CIS600`
    3. request a certificate of user `CIS600` to CA for signing; (hint: use `CIS600`'s public key as his identity)

cp private/cakey.pem private/cakey.pem.enc
openssl rsa -in private/cakey.pem.enc -out private/cakey.pem

#

openssl req -nodes -new -x509 -keyout cs691privatekey.pem -out cs691req.pem -days 365 -config /etc/ssl/openssl.cnf
openssl x509 -x509toreq -in cs691req.pem -signkey cs691privatekey.pem -out cs691certrequest.pem

#/*** here we need to make a couple of files, otherwise the next openssl command will produce errors ***/
#mkdir newcerts; touch index.txt; echo 01>serial; Edit /etc/ssl/openssl.cnf and set two appearances of dir= CADemo to dir= .
openssl ca -config /etc/ssl/openssl.cnf -policy policy_anything -out cs691signedcert.pem -infiles cs691certrequest.pem
cp cs691privatekey.pem private/cs691privatekey.pem
openssl rsa -in private/cs691privatekey.pem -passin pass:cs03se -pubout -out cs691publickey.pem

    4. use the public-private key pair to encrypt and decrypt messages
    5. use the public-private key pair to sign and verify messages 

echo "sometext">plain.txt
openssl rsautl -encrypt -pubin -inkey cs691publickey.pem -in plain.txt -out cipher.txt
openssl rsautl -decrypt -inkey private/cs691privatekey.pem -in cipher.txt -out plainRcv.txt
openssl sha1 -out digest.txt plain.txt
openssl sha1 -sign private/cs691privatekey.pem -out rsasign.bin plain.txt
openssl sha1 -verify cs691publickey.pem -signature rsasign.bin plain.txt
-->
<!--
  
Homework 4
---

1. **Merkle tree collision-resistance** [Exercise 5.12] Prove theorem 5.11, that is, the collision-resistance of Merkle tree depends on the collision-resistance of the hash function used in Merkle tree.
2. **Merkle tree for variable-length hash** [Exercise 5.13] Show how to find a collision in the Merkle tree construction if $t$ is not fixed. Specifically, show how to find two sets of inputs $x_1,...,x_t$ and $x_1',...,x_{2t}'$, such that $MT_t(x_1,...,x_t)=MT_{2t}(x_1',...,x_{2t}')$.
    - Can you design an approach to fix the problem and have variable-length collision resistant Merkle tree? 
3. [Bonus: 20/100] Consider a variable-length Merkle-tree scheme $MT$ and a message space ${M}$ where there is an ordering scheme (i.e. total order between two messages). Use $MT_{M}$ to digest an ordered list of *distinct* messages. Can $MT_{M}$ support the merge operation of the two lists? Given two lists, the merge result is an ordered list of distinct messages. Formally, consider two lists $m^A=m^A_1m^A_2...m^A_t$ and $m^B=m^B_1m^B_2...m^B_{t'}$ where (w.o.l.g.) $m^A_1<m^A_2<...<m^A_t$ and $m^B_1<m^B_2<...<m^B_{t'}$. $m:=merge(m^A,m^B)$ where $m$ contains all blocks in $\{m^A_1,m^A_2,...,m^A_t,m^B_1,m^B_2,...,m^B_{t'}$, is an ordered list, and has all blocks distinct. Denote by $d^A$ the root hash of Merkle tree $MT_{M}(m^A)$ and $d^B$ that of $MT_{M}(m^B)$. Would it be possible to compute $d$, the root hash of $MT_{{M}}(merge(m^A,m^B))$ directly from $d^A$ and $d^B$?
    - Hint: To make it non-trivial, one can ignore the case that two lists are non-overlapping and totally-ordered.
-->
<!--

4. **Authenticated Data Structures** [Exercise 1 from book `BtC` (Bitcoin and Cryptocurrency Technologies); Page 49].
    - hint: In Merkle tree, sublinear proof of non-membership is very similar to that of proving membership.

-->
<!--

Homework 5
---

1. **Model of Mining** [Exercise 6a, 6b from book `BtC` (Bitcoin and Cryptocurrency Technologies); Page 74].
    - hint: read chapter 2.4
    - further reading about probability used in Blockchain: [[pdf](https://arxiv.org/abs/1701.03977)]
2. Project 1: **Blockchain Mining**: [[Link in BB](https://blackboard.syr.edu/bbcswebdav/courses/41635.1172/project.pdf)]
3. (Homework 4, Problem 3)

Homework 6
---

1. Project 2 (Programming option): **Secure distributed file systems and PKI**:: [[Link in BB](https://blackboard.syr.edu/bbcswebdav/courses/41635.1172/proj2-sdfs.pdf)]
2. **Blockchain transactions** [Bonus 20/100] This programming task follows "Project 1 Blockchain mining." You are required to demonstrate the following:
    - register two accounts in Ethereum, say `A` and `B`. 
    - earn `Ether`/`Wei` in your account `A`; Earning Ether can be done by Ethereum faucet, verifying smart-contract, etc.
    - in Client `geth`/`eth`, send a transaction to transfer the Ether from `A` to `B`.

-->
</body>
</html>
